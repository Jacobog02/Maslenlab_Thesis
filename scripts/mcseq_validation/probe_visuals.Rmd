---
params:
  wrkdir: NA
  expname: NA
  set_title: 'Default Probe Validation Visualization'
  set_author: 'Created by Jacob Gutierrez'
fig_width: 12
fig_height: 6
---



```{r check args, echo = F}
args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 2) {
  expname <- args[1]
  wrkdir <- args[2]
  set_title <- sprintf('%s: Probe Validation Visualization',expname)
  notation= 'chr'
  #outfile <- sprintf('%s/%s_probe_visuals.html',wrkdir,expname)
  #print(outfile)
  #print('HERE')
  #print(set_title)
} else if(length(args) == 3) {
  expname <- args[1]
  wrkdir <- args[2]
  set_title <- sprintf('%s: Probe Validation Visualization',expname)
  notation= ''
} else{
  stop("Experiment Name and Working Directory required to generate html output", call.=FALSE)
}
```



---
title: "`r set_title`"
author:  "`r params$set_author`"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document:
    df_print: paged
    toc: true
    toc_float: true
---


<!-- Use this option in the end: `knitr::opts_chunk$set(echo = F, message= F)` -->

<!-- We want to hide the code but show the results.  -->

<!-- To Run: rmarkdown::render('render_test1.Rmd','html_document',params = list(year = 2019)) -->

```{r setup , include=FALSE}
knitr::opts_chunk$set(echo = F, message= F)
#knitr::knit_exit()
```





<!-- MODIFY THE PARAMS IN ORDER TO KNOW ONLY WRKDIR AND EXPNAME BUT THIS WILL WORK FOR NOW TO MAKE IT WORK AND MAKE THE PLOTS -->



```{r file path setting, eval = F}

expname = 'ECP4' #params$expname

wrkdir = '/home/groups/hoolock2/u0/jg/thesis/sa1/ECP4' #params$wrkdir

notation = ''#'chr'

# Use params to make the setting 
cov_file =  sprintf('%s/%s_cov.bed',wrkdir,expname)                                                                                 
int_out = sprintf('%s/%s_int_output.csv',wrkdir,expname) 

 
int_data = sprintf('%s/%s_int.Rdata',wrkdir,expname)
#dir <- base::dirname(params$cov_file)# This gets the working directory path
#basename(params$cov_file) # this gets the file name!
```




```{r libraries,message = F, echo = F}
#BiocManager::install('genomation')
#library(genomation) # check if you use this 
library(tidyverse) # the good stuff
library(rtracklayer) #Granges import
library(GenomicRanges) # Granges
#library(gridExtra) # arranging plots
library(knitr) # html modification
library(kableExtra) # More html modification
select <- dplyr::select
rename <- dplyr::rename

# Declare functions
set_exp_name <- function(exp_id){
  
  buffer = str_split(exp_id, '_', simplify = T)
  buffer = buffer[,ncol(buffer)]
  exp_id <- setNames(exp_id, buffer)
  
  return(exp_id)
}


```

## Summary

This R notebook is to be used to generate visualizations of the bedfiles generated by bedtools coverage and interval. 

The coverage function is used to generate a grouped data for each sample which can be assessed for probe effeciency. 

The inverval negate data gives how many reads were not within the probe region and what their distribution is. 

Lastly this script generates a failed_probes.bed file of the probes which had no reads within a given region to be used for followup analysis. 


```{r data read in, message=F, warning=F}
# Reading in all data
ECP4_multi<- read_delim(cov_file,delim = ' ')


# Read in the interval_data
interval_summary <- read_csv(int_out)

# 2 objects `mian_grange` and `out_of_probe_reads`
load(int_data)

```


 
 
```{r filter for chr of interest}
chr_wanted <- c(paste(notation,seq(22),sep=''), paste(notation,c('X','Y'), sep=''))

# Filter for only the ones we want in coverage
ECP4_multi <- ECP4_multi %>% filter(chr %in% chr_wanted)

# Filter the granges object
#main_grange <- main_grange[seqnames(main_grange) %in% chr_wanted]

# Filter interval dataframe
out_of_probe_reads <- out_of_probe_reads %>% filter(chr %in% chr_wanted)

```
 
 
 
 
```{r generate ggplottable dataframe}
exp_id = ECP4_multi %>% select(starts_with('read_num')) %>% colnames()

# function goes here to make the named vector
exp_id = set_exp_name(exp_id)

#%>%  rename(!!exp_id) Cant select well I have to do a mutate in Exp....
common_cols <- ECP4_multi %>% select(1:5) %>% colnames() # extract common columns to use later on. 

# Make read number into the long format.
plottable_reads <- ECP4_multi %>% select(common_cols, starts_with('read_num')) %>% gather('experiment', 'read_count',  starts_with('read_num')) %>% mutate(experiment = str_split_fixed(experiment, '_',n=3)[,3]) %>% mutate(experiment = as.factor(experiment))

plottable_cov <- ECP4_multi %>% select(common_cols, starts_with('frac_cov')) %>% gather('experiment', 'coverage',  starts_with('frac_cov')) %>% mutate(experiment = str_split_fixed(experiment, '_',n=3)[,3]) %>% mutate(experiment = as.factor(experiment)) %>% mutate(coverage = as.factor(round(coverage,1))) %>% mutate(coverage = fct_rev(coverage))


plottable_reads <- plottable_reads %>% mutate(log_count = log(read_count), log_count = if_else(log_count == -Inf, 0, log_count)) 
```


```{r format interval output}
# Read in the interval_data
#interval_data <- suppressMessages(read_csv(int_out))

# subtract 1 bc the header is included 
#interval_summary <- interval_summary %>%  mutate(perc = (readsout-1)/totalreads) 


## THis only works bc 4th column when split is the file handle. Maybe make it find the bed item and then the handle before it. 
# find the file names
## JG 4/15/20 Create vector of sample ids. 
#interval_summary <- interval_summary %>% rowwise() %>% mutate(clean_name = str_split(filename, '\\.') %>% unlist() %>% .[3]) %>% ungroup()

## First get the inner string then split on the '_'
name_vect <- str_split_fixed(interval_summary$filename, '\\.',n=3) %>% .[,2] %>% str_split_fixed('_',n=2) %>% .[,2]

interval_summary$clean_name <-  name_vect


### Old Way!
# interval_summary <- interval_summary %>% arrange(desc(totalreads)) %>% mutate(clean_name = as.factor(clean_name))
# 
# tot_ord <- interval_summary %>% pull(clean_name)
# 
# interval_summary <- interval_summary %>% mutate(clean_name = factor(clean_name,levels(tot_ord)[as.integer(tot_ord)]))

## New way! JG 4/15/20
interval_summary <- interval_summary %>% arrange(desc(totalreads)) %>% mutate(clean_name = factor(clean_name, levels = clean_name))

```




<!-- ## Probe Introduction -->

<!-- JG 4/15/20 I decided to remove this section from the html output! -->


<!-- ```{r number of probes per chr} -->
<!-- # Count chr. -->
<!-- chr_count <- ECP4_multi %>% group_by(chr) %>% count() %>% ungroup() # count the chr -->

<!-- # Convert to factor to order levels  -->
<!-- chr_count <- chr_count %>% mutate(chr = as.factor(gsub('chr','',chr))) -->

<!-- # Find the order based on the count.  -->
<!-- chr_order <- chr_count$chr[order(chr_count$n, decreasing = T)]  -->
<!-- # refactor the chrs -->
<!-- chr_count <- chr_count %>% mutate(chr = factor(chr, levels = chr_order))  -->

<!-- chr_count <- chr_count %>% arrange(chr) # sort based on the levels -->

<!-- # Adding Chr Name -->
<!-- #chr_count <- chr_count %>% mutate(chr = as.factor(gsub('chr','',chr))) -->

<!-- #chr_count%>% kable() %>% kable_styling() %>% scroll_box(height = '200px') # display table  -->

<!-- # Make barplot -->
<!-- chr_count %>% ggplot(aes(x=chr,y=n, fill=chr)) + geom_col() + theme_classic() + -->
<!--   # Customize theme Here -->
<!--   #theme(axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank(), legend.position = 'None') +  -->
<!--   theme( axis.ticks.x = element_blank(), legend.position = 'None') + -->
<!--   # Show Chr number and maybe hide the legend -->
<!--   #geom_text(aes(label=chr), vjust=0) +#, size =2.5) -->
<!--   # Adding Count data but I might ignore -->
<!--   geom_text(aes(label=n), vjust=0, size =2) +  -->
<!--   # Adding Titles -->
<!--   ggtitle(sprintf('%s Total Number of Probes by Chromosome labeled',expname)) + ylab('Number of Probes') + xlab("Chromsome") -->


<!-- ``` -->


<!-- > This shows the number of probes by chromosmoe to introduce how many probes are used in the analysis as well as the chromosomal distribution of these probes.  -->


<!-- ```{r} -->
<!-- # Make this be fancy html table. -->
<!-- buffer <-  summary(ECP4_multi$probe_length) -->


<!-- display <- rbind(names(buffer),round(as.vector(buffer))) -->

<!-- display %>% kable(caption = sprintf('%s: Summary Statistics of Probe Length (bp)',expname)) %>% kable_styling() -->

<!-- #p1 <- ECP4_multi %>% ggplot(aes(x=probe_length)) + geom_density() + -->
<!-- ``` -->

<!-- > Summary statistics of the length of the probe regions. This will depend on the library prep used.  -->


## Total Read Counts 

```{r}
buffer <- interval_summary %>% mutate(readsin = totalreads - readsout) %>% select(-filename , - totalreads)

buffer <- buffer %>% gather('read_info','number',-clean_name) %>% 
  group_by(clean_name) %>% 
  left_join(., interval_summary %>% select(clean_name,totalreads), by = 'clean_name') %>%
  mutate(perc = sprintf('%.0f%%',number/totalreads * 100), ypos = cumsum(number) - .5*number) # format percentages

buffer %>% 
  ggplot(aes(x=clean_name, y=number)) + geom_col(aes(fill=read_info)) + geom_text(aes(y=ypos, label = perc), vjust=0, size =3) + 
  geom_text( aes(x=clean_name,y=totalreads,label=totalreads), data = (interval_summary %>% select(clean_name,totalreads)), vjust=0, size =1.8) +
  ggtitle(paste(expname,'\nTotal Number of Reads per Sample')) + ylab('Number of Reads') + xlab('Experiment') + scale_fill_discrete(name = "Reads", labels = c("Within Probes", "Out of Probes")) + theme_classic() 

```

> We expect similar number of reads for each sample within the same library prep.




<!-- ## Number of reads per experiment -->


<!-- ```{r, eval = F} -->
<!-- read_totals <- plottable_reads %>% group_by(experiment) %>% summarize(read_total = sum(read_count)) %>% arrange(desc(read_total))  -->

<!-- tot_ord <- read_totals %>% pull(experiment) -->

<!-- read_totals <- read_totals %>% mutate(experiment = factor(experiment,levels(tot_ord)[as.integer(tot_ord)])) -->


<!-- read_totals %>% ggplot(aes(experiment,read_total,fill=experiment)) + geom_col() + ggtitle(paste(expname, '\nNumber of Reads within Probe Regions')) + theme_classic() + theme(legend.position = 'none') -->
<!-- ``` -->



## Faction of Probes Not Covered by Reads



```{r probes not covered}
# Find number of probes with 0's by experiment
total_zeros <- plottable_reads %>% filter(read_count == 0)

# This gets the unique probe ids 
probes_failed_all <- plottable_reads %>% group_by(probe_id) %>% filter(all(read_count == 0)) %>% ungroup() %>% distinct(probe_id) %>% pull()

#
read_totals <- total_zeros %>% group_by(experiment) %>% count(read_count) %>% arrange(desc(n)) %>% ungroup()

tot_ord <- read_totals %>% pull(experiment)

read_totals <- read_totals %>% mutate(experiment = factor(experiment,levels(tot_ord)[as.integer(tot_ord)]))


#read_totals %>% ggplot(aes(experiment,n,fill=experiment)) + geom_col() + ggtitle(sprintf('%s Number of Probes with No Coverage',expname))
```


```{r plot proportion of coverage}
plottable_cov %>% group_by(experiment) %>% count(coverage) %>% ggplot(aes(experiment,n,fill=coverage)) + geom_col(position = 'fill') + ggtitle(paste(expname,'\nProportion of probe coverage by sample')) + ylab('') + xlab('Sample') + theme_classic()
```


> We plot the proportion of coverage for each probe. We expect the majority of probes to have full coverage (1) and a minority to show less than ideal coverage. Additionally we expect the coverage not to vary drastically between samples with uniform coverages within an experiment. 




## Probes failed across all samples


```{r Probes failed in all samples}
# Find all failed probes 
failed_all_bed <- plottable_reads %>% filter(probe_id %in% probes_failed_all) %>% select(chr,start,stop) %>% count(chr) %>% arrange(desc(n)) #%>% mutate_all(as.factor)#%>% mutate(chr = as.factor(chr))#, score =  as.factor(1)) # The score is used for manhatten plot

# Total probe number
probe_counts <- plottable_reads %>% group_by(chr) %>% count() %>% ungroup() %>% rename(total=n) #%>% mutate_all(as.factor)

# Merge together only keeping chr that contain failed
failed_all_bed <- right_join(probe_counts,failed_all_bed,by='chr') %>% mutate_all(as.factor)


# Remove 'chr' 
failed_all_bed <- failed_all_bed %>% mutate(chr = as.factor(gsub('chr','',chr)))

# extract te order 
tot_ord <- failed_all_bed %>% pull(chr)


# Reorder based on the failed counts
failed_all_bed <- failed_all_bed %>% mutate(chr = factor(chr,levels(tot_ord)[as.integer(tot_ord)]))


# extract percentage 
extract_int <- function(x){ as.character(x) %>% as.integer() }
norm <- failed_all_bed %>% mutate_at(vars(-chr), extract_int) %>% 
  mutate(norm = round(n/total * 100, 2) %>% as.character) %>% mutate(norm = paste(norm,'%',sep='')) %>% 
  select(chr,total,norm)

# Compute in and out and gather
plottable_failed <- failed_all_bed %>% mutate_at(vars(-chr), extract_int) %>% mutate(probes_passed = total-n) %>% select(chr,probe_failed=n, probes_passed) %>% gather(probe_status, count, -chr)


# Plot it
plottable_failed %>% ggplot(aes(chr,count)) + geom_col(aes(fill=probe_status)) +
  geom_text(data=norm,aes(x=chr,y=total, label=norm), vjust=0, size =2.5) + 
  theme_classic() + #theme(legend.position = 'None') + 
  ggtitle(paste(expname,"\nNumber of Probes failed in all samples by Chromosome")) + ylab('Number of probes') + xlab('Chromosome') 
```

> Count of probes that failed within all samples (Have 0 reads in the probe area). This can be compared against the probe distribution plot to observe if there are any chr that are enriched for failed probes.  





## Assess Total Effeciency

The Sample Effeciency will be calcualted as follows

$$ \text{Sample Effeciency Metric}(SEM) =\frac{\text{# Reads Within Probe Regions}}{\text{# Reads Out of Probe Regions}}$$
 
To compare within the experiment the Effeciency metric is normalized by the total number of reads within the sample on a log scale

 $$ \text{Normalized Sample Effeciency Metric} (NSEM) = \frac{ \text{SEM} }{ \text{log} ( \text{Total # Reads})}$$
 
```{r make effeciency metric, warning=F}
# Number of reads in the probe region
Reads_in_probes <- ECP4_multi %>% select(starts_with('read_num')) %>% # Make it multi line after pipe
  summarise_all(sum) %>% gather('experiment','tot_reads_in')  %>% mutate(experiment = gsub('read_num_','', experiment)) 

Reads_out_probes <- interval_summary %>% select(clean_name, readsout, totalreads) %>% rename(experiment = clean_name)

efficency_table <- left_join(Reads_in_probes, Reads_out_probes, by = "experiment")

efficency_table <-  efficency_table %>% mutate(effeciency_metric = tot_reads_in / readsout , norm_metric = effeciency_metric/log(totalreads)) #%>% 
  #mutate(norm_metric = metric/ totalreads , log2_norm_metric = metric/ log(totalreads))

display <- efficency_table %>% select(sample = experiment, effeciency_metric, norm_metric ) %>% t() %>% as.data.frame()

display %>% kable(col.names = NULL) %>% kable_styling()
```
 

> We expect that all samples have similar effeciency.   Taken roughly a positive effeciency score means there are more reads within the probe region than outside of it and the value indicates the proportion of reads in the probe region than outside the probe region.   For example an effeciency metrix of 3 indicates there are 3 times as many reads within the probe region than outside the probe region.   The normalized metric allows for direct comparison across samples with larger scores indicating greater effeciency.



## Another Effeciency Metric


Another way to display the effeciency is to directly normalize the reads within and outside of the probe regions by the total number of reads within that sample as shown below

$$ \text{Effeciency Metric}(EM) =\frac{\text{# Reads Within Probe Regions} / \text{ Total Reads}}{\text{# Reads Out of Probe Regions} / \text{ Total Reads}}$$

```{r, warning=F}
efficency_table <- left_join(Reads_in_probes, Reads_out_probes, by = "experiment")

efficency_table <-  efficency_table %>% mutate(n_in = tot_reads_in / totalreads , n_out = readsout/ tot_reads_in, effeciency_metric = n_in/ n_out) #%>% 
  #mutate(norm_metric = metric/ totalreads , log2_norm_metric = metric/ log(totalreads))

display <- efficency_table %>% select(sample = experiment, effeciency_metric) %>%  t() %>% as.data.frame()

display %>% kable(col.names = NULL) %>% kable_styling()
```


>  Again; We expect that all samples have similar effeciency.   Taken roughly a positive effeciency score means there are more reads within the probe region than outside of it and the value indicates the proportion of reads in the probe region than outside the probe region.   For example an effeciency metrix of 3 indicates there are 3 times as many reads within the probe region than outside the probe region.   The normalized metric allows for direct comparison across samples with larger scores indicating greater effeciency.


```{r output failed}
# Addded 9/10/19 
failed_output <- ECP4_multi %>% select(chr,start,stop,probe_id,probe_length) %>% filter(probe_id %in% probes_failed_all)
failed_path =  sprintf('%s/%s_failed_probes.bed',wrkdir,expname)  
write_tsv(failed_output,path=failed_path,col_names = FALSE)
```


