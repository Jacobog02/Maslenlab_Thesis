---
title: "`r params$set_title`"
author: "`r params$set_author`"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    df_print: paged
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: false
    theme: yeti
subtitle: "Thesis Project: SA1"
params:
  expname: NA
  wrkdir: NA
  set_title: 'Default Probe Validation Visualization'
  set_author: 'Created by Jacob Gutierrez'
---

```{r, echo = F}
## Knitr setupchunk
knitr::opts_chunk$set(fig.width=12, fig.height=12, echo=TRUE, warning=FALSE, message=FALSE, rows.print=2, eval = TRUE)
```

# Purpose: {.tabset .tabset-fade .tabset-pills}

This script is expected to run on Hoolock2 See sessionInfo for more info.


# Analysis:

#### Data Read In:

```{r file path setting}

#expname = 'ECP4' #params$expname
expname = params$expname

wrkdir = params$wrkdir 
#wrkdir ='/home/groups/hoolock2/u0/jg/thesis/sa1/ECP4' #params$wrkdir

notation = ''#'chr'

# Use params to make the setting 
cov_file =  sprintf('%s/%s_cov.bed',wrkdir,expname)                                                                                 
int_out = sprintf('%s/%s_int_output.csv',wrkdir,expname) 

 
int_data = sprintf('%s/%s_int.Rdata',wrkdir,expname)
#dir <- base::dirname(params$cov_file)# This gets the working directory path
#basename(params$cov_file) # this gets the file name!
```

#### Libraries:
```{r libraries,message = F, echo = F}
#BiocManager::install('genomation')
#library(genomation) # check if you use this 
library(tidyverse) # the good stuff
library(rtracklayer) #Granges import
library(GenomicRanges) # Granges
#library(gridExtra) # arranging plots
library(knitr) # html modification
library(kableExtra) # More html modification
select <- dplyr::select
rename <- dplyr::rename

# Declare functions
set_exp_name <- function(exp_id){
  
  buffer = str_split(exp_id, '_', simplify = T)
  buffer = buffer[,ncol(buffer)]
  exp_id <- setNames(exp_id, buffer)
  
  return(exp_id)
}

jg_pretty_print <- function(df, cap = NA){
  
  df %>%  kable(caption = cap) %>% 
    kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive") , full_width = F, position = "left") %>%  
    scroll_box(width = "100%")
  
} 



```

## Summary

This R notebook is to be used to generate visualizations of the bedfiles generated by bedtools coverage and interval. 

The coverage function is used to generate a grouped data for each sample which can be assessed for probe effeciency. 

The inverval negate data gives how many reads were not within the probe region and what their distribution is. 

Lastly this script generates a failed_probes.bed file of the probes which had no reads within a given region to be used for followup analysis. 



```{r data read in, message=F, warning=F}
# Reading in all data
ECP4_multi<- read_delim(cov_file,delim = ' ')


# Read in the interval_data
interval_summary <- read_csv(int_out)

# 2 objects `mian_grange` and `out_of_probe_reads`
load(int_data)

```


 
 
```{r filter for chr of interest}
chr_wanted <- c(paste(notation,seq(22),sep=''), paste(notation,c('X','Y'), sep=''))

# Filter for only the ones we want in coverage
ECP4_multi <- ECP4_multi %>% filter(chr %in% chr_wanted)

# Filter the granges object
#main_grange <- main_grange[seqnames(main_grange) %in% chr_wanted]

# Filter interval dataframe
out_of_probe_reads <- out_of_probe_reads %>% filter(chr %in% chr_wanted)

```


```{r generate ggplottable dataframe}
exp_id = ECP4_multi %>% select(starts_with('read_num')) %>% colnames()

# function goes here to make the named vector
exp_id = set_exp_name(exp_id)

#%>%  rename(!!exp_id) Cant select well I have to do a mutate in Exp....
common_cols <- ECP4_multi %>% select(1:5) %>% colnames() # extract common columns to use later on. 

# Make read number into the long format.
plottable_reads <- ECP4_multi %>% select(common_cols, starts_with('read_num')) %>% gather('experiment', 'read_count',  starts_with('read_num')) %>% mutate(experiment = str_split_fixed(experiment, '_',n=3)[,3]) %>% mutate(experiment = as.factor(experiment))

plottable_cov <- ECP4_multi %>% select(common_cols, starts_with('frac_cov')) %>% gather('experiment', 'coverage',  starts_with('frac_cov')) %>% mutate(experiment = str_split_fixed(experiment, '_',n=3)[,3]) %>% mutate(experiment = as.factor(experiment)) %>% mutate(coverage = as.factor(round(coverage,1))) %>% mutate(coverage = fct_rev(coverage))


plottable_reads <- plottable_reads %>% mutate(log_count = log(read_count), log_count = if_else(log_count == -Inf, 0, log_count)) 
```


```{r format interval output}
# Read in the interval_data
#interval_data <- suppressMessages(read_csv(int_out))

# subtract 1 bc the header is included 
#interval_summary <- interval_summary %>%  mutate(perc = (readsout-1)/totalreads) 


## THis only works bc 4th column when split is the file handle. Maybe make it find the bed item and then the handle before it. 
# find the file names
## JG 4/15/20 Create vector of sample ids. 
#interval_summary <- interval_summary %>% rowwise() %>% mutate(clean_name = str_split(filename, '\\.') %>% unlist() %>% .[3]) %>% ungroup()

## First get the inner string then split on the '_'
name_vect <- str_split_fixed(interval_summary$filename, '\\.',n=3) %>% .[,2] %>% str_split_fixed('_',n=2) %>% .[,2]

interval_summary$clean_name <-  name_vect


### Old Way!
# interval_summary <- interval_summary %>% arrange(desc(totalreads)) %>% mutate(clean_name = as.factor(clean_name))
# 
# tot_ord <- interval_summary %>% pull(clean_name)
# 
# interval_summary <- interval_summary %>% mutate(clean_name = factor(clean_name,levels(tot_ord)[as.integer(tot_ord)]))

## New way! JG 4/15/20
interval_summary <- interval_summary %>% arrange(desc(totalreads)) %>% mutate(clean_name = factor(clean_name, levels = clean_name))

```


## Efficiency Metric

```{r make effeciency metric, warning=F}
# Number of reads in the probe region
Reads_in_probes <- ECP4_multi %>% select(starts_with('read_num')) %>% # Make it multi line after pipe
  summarise_all(sum) %>% 
  gather('experiment','tot_reads_in')  %>% 
  mutate(experiment = gsub('read_num_','', experiment)) 

Reads_out_probes <- interval_summary %>% select(clean_name, readsout, totalreads) %>% rename(experiment = clean_name)

efficency_table <- left_join(Reads_in_probes, Reads_out_probes, by = "experiment")

efficency_table <-  efficency_table %>% mutate(n_in = tot_reads_in / totalreads , n_out = readsout/ totalreads, effeciency_metric = n_in/ n_out) #%>% 
  #mutate(norm_metric = metric/ totalreads , log2_norm_metric = metric/ log(totalreads))

display <- efficency_table %>% select(sample = experiment, effeciency_metric) %>%  t() %>% as.data.frame()
#colnames(display) <- display$sample


display %>% kable(col.names = NULL) %>%  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive") , full_width = F, position = "left") %>%  
    scroll_box(width = "100%", height = "300px")

eff_path =  sprintf('%s/%s_efficiency_df.csv',wrkdir,expname) 
print(eff_path)
write_csv(efficency_table,path=eff_path,col_names = TRUE)
```

>  We expect that all samples have similar effeciency.   Taken roughly a positive effeciency score means there are more reads within the probe region than outside of it and the value indicates the proportion of reads in the probe region than outside the probe region.   For example an effeciency metrix of 3 indicates there are 3 times as many reads within the probe region than outside the probe region.   The normalized metric allows for direct comparison across samples with larger scores indicating greater effeciency.


```{r, eval = F, include = F}
## Not used in execution
# Make df
test = data.frame(exp =c(1,1,2,2), samp= c(1,2,1,2) ,nin = c(75,275,130,195), nout =c(25,25,20,29), ntotal = c(100,300,150,224))

# Process
test <- test %>% mutate(ftotal = sum(ntotal))
test <- test %>% group_by(exp) %>% summarize(exp_total = sum(ntotal)) %>% left_join(test,.)

## Original method
test %>% group_by(exp) %>% mutate(efin = nin/exp_total, efout = nout/exp_total, eff1 = efin/efout) 

## More normalized but still replects the original number 
test %>% mutate(nin = nin/ftotal, nout = nout/ftotal, ntotal = ntotal/ftotal) %>% mutate(efin = nin/exp_total, efout = nout/exp_total, eff1 = efin/efout)
```




## Total Read Counts 

```{r}
buffer <- interval_summary %>% mutate(readsin = totalreads - readsout) %>% select(-filename , - totalreads)

buffer <- buffer %>% gather('read_info','number',-clean_name) %>% 
  group_by(clean_name) %>% 
  left_join(., interval_summary %>% select(clean_name,totalreads), by = 'clean_name') %>%
  mutate(perc = sprintf('%.0f%%',number/totalreads * 100), ypos = cumsum(number) - .5*number) # format percentages

g1 <- buffer %>% 
  ggplot(aes(x=clean_name, y=number)) + geom_col(aes(fill=read_info)) + geom_text(aes(y=ypos, label = perc), vjust=0, size =3) + 
  geom_text( aes(x=clean_name,y=totalreads,label=totalreads), data = (interval_summary %>% select(clean_name,totalreads)), vjust=0, size =1.8) +
  ggtitle(paste(expname,'\nTotal Number of Reads per Sample')) + ylab('Number of Reads') + xlab('Experiment') + scale_fill_discrete(name = "Reads", labels = c("Within Probes", "Out of Probes")) + theme_classic() 

g1
```


## Faction of Probes Not Covered by Reads



```{r probes not covered}
# Find number of probes with 0's by experiment
total_zeros <- plottable_reads %>% filter(read_count == 0)

# This gets the unique probe ids 
probes_failed_all <- plottable_reads %>% group_by(probe_id) %>% filter(all(read_count == 0)) %>% ungroup() %>% distinct(probe_id) %>% pull()

#
read_totals <- total_zeros %>% group_by(experiment) %>% count(read_count) %>% arrange(desc(n)) %>% ungroup()

tot_ord <- read_totals %>% pull(experiment)

read_totals <- read_totals %>% mutate(experiment = factor(experiment,levels(tot_ord)[as.integer(tot_ord)]))


#read_totals %>% ggplot(aes(experiment,n,fill=experiment)) + geom_col() + ggtitle(sprintf('%s Number of Probes with No Coverage',expname))
```


```{r plot proportion of coverage}
g2 <- plottable_cov %>% group_by(experiment) %>% count(coverage) %>% ggplot(aes(experiment,n,fill=coverage)) + geom_col(position = 'fill') + ggtitle(paste(expname,'\nProportion of probe coverage by sample')) + ylab('') + xlab('Sample') + theme_classic()
g2
```


> We plot the proportion of coverage for each probe. We expect the majority of probes to have full coverage (1) and a minority to show less than ideal coverage. Additionally we expect the coverage not to vary drastically between samples with uniform coverages within an experiment. 




## Probes failed across all samples


```{r Probes failed in all samples}
# Find all failed probes 
failed_all_bed <- plottable_reads %>% filter(probe_id %in% probes_failed_all) %>% select(chr,start,stop) %>% count(chr) %>% arrange(desc(n)) #%>% mutate_all(as.factor)#%>% mutate(chr = as.factor(chr))#, score =  as.factor(1)) # The score is used for manhatten plot

# Total probe number
probe_counts <- plottable_reads %>% group_by(chr) %>% count() %>% ungroup() %>% rename(total=n) #%>% mutate_all(as.factor)

# Merge together only keeping chr that contain failed
failed_all_bed <- right_join(probe_counts,failed_all_bed,by='chr') %>% mutate_all(as.factor)


# Remove 'chr' 
failed_all_bed <- failed_all_bed %>% mutate(chr = as.factor(gsub('chr','',chr)))

# extract te order 
tot_ord <- failed_all_bed %>% pull(chr)


# Reorder based on the failed counts
failed_all_bed <- failed_all_bed %>% mutate(chr = factor(chr,levels(tot_ord)[as.integer(tot_ord)]))


# extract percentage 
extract_int <- function(x){ as.character(x) %>% as.integer() }

norm <- failed_all_bed %>% mutate_at(vars(-chr), extract_int) %>% 
  mutate(norm = round(n/total * 100, 2) %>% as.character) %>% mutate(norm = paste(norm,'%',sep='')) %>% 
  select(chr,total,norm)

# Compute in and out and gather
plottable_failed <- failed_all_bed %>% mutate_at(vars(-chr), extract_int) %>% mutate(probes_passed = total-n) %>% select(chr,probe_failed=n, probes_passed) %>% gather(probe_status, count, -chr)

## Chaning probe_status to look pretty
plottable_failed <- plottable_failed %>% mutate(probe_status = if_else(probe_status == "probe_failed", "Failed","Passed")) %>% rename("Target Status" = probe_status)

# Plot it
g3 <- plottable_failed %>% ggplot(aes(x=chr,y=count)) + geom_col(aes(fill=`Target Status`)) +
  geom_text(data=norm,aes(x=chr,y=total, label=norm), vjust=0, size =2.5) + 
  theme_classic() + 
  ggtitle(paste(expname,"\nNumber of Probes failed in all samples by Chromosome")) + ylab("Target Count") + xlab('Chromosome') 

g3
```

> Count of probes that failed within all samples (Have 0 reads in the probe area). This can be compared against the probe distribution plot to observe if there are any chr that are enriched for failed probes.  



```{r output failed}
# Addded 9/10/19 
failed_output <- ECP4_multi %>% select(chr,start,stop,probe_id,probe_length) %>% filter(probe_id %in% probes_failed_all)
failed_path =  sprintf('%s/%s_failed_probes.bed',wrkdir,expname)  
write_tsv(failed_output,path=failed_path,col_names = FALSE)
```

```{r plot output}
to_save <- list(read_count_plt <- g1, cov_plt <- g2, chr_fail_plot <- g3)
plt_path =  sprintf('%s/%s_plots.Rds',wrkdir,expname) 
saveRDS(to_save, plt_path)

```



### SessionInfo:

```{r}
sessionInfo()
```

